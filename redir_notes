/*
int Executor(t_words **words)


		if simple command: (NO PIPE)
			1. check for redirections
				in case command has a < or << token, we have to go from right, until only tokens > or >> are left
				afterwards we have to check if the command is a keyword
				ONLY ONE COMMAND WITH ONE INPUT CAN BE LEFT BEFORE WE GET TO 2.
			2. check if command is a keyword witch cat.
			3.execve
		if pipe:
			get the output of the first command
				1. check for redirections
					in case command has a < or << token, we have to go from right, until only tokens > or >> are left
					afterwards we have to check if the command is a keyword
					ONLY ONE COMMAND WITH ONE INPUT CAN BE LEFT BEFORE WE GET TO 2.
			2. check if command is a keyword
				if it was redirected, putstr_fd with cat
				if not dup2
			3.
			
			while (words[i])
			{
				if simple 
				{
					if check redirection
						do redirection(it should rewrite contents of this words element) here we should consider that 
						until fds are sorted evberything is waiting on that. 
					if check keyword
						do keyword on fd or on next word
					else
						execve with word
				}
				if pipe
				sort out frist element with if simple
					duplicate the output to the input of the next element
						check keyword, if yes, do keyword on fd or on next word
						else execve with word to dup2 stdout
				i++;
			}

		check redirection / do  redirection 
			if strchr < or << 
				get file to the right or token and cat? it to the fd of left file.
				repeat until no strchr < or <<
			else if only one token cat to fd of right file.
			if more tokens then RESEARCH BEHAVIOR OF BASH.

*/